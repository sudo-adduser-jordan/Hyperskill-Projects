<h2>Parallel iteration</h2>
<html><body><p><strong>Parallel iteration</strong> is the way to access elements of more than one iterable simultaneously. This can be useful when you want to combine two data structures or when you want to access more than one iterable element in one <code class="language-python">for</code> loop. In this topic, we will learn how to do all these things using the built-in <code class="language-python">zip()</code> function.</p>
<h5 id="the-zip-function">The zip() function</h5>
<p><code class="language-python">Zip()</code> takes multiple iterables and zips them together into one iterator, just like a zipper that binds the interlocking teeth of a zip.</p>
<p style="text-align: center;"><img alt="" height="127" name="Zipper.svg" src="https://ucarecdn.com/7146b701-a8d9-45dd-bd6f-b8091824fda5/" width="236"/></p>
<p>The function can take any number of iterables and then returns an <strong>iterator of tuples</strong>. Each generated tuple contains one element from every iterable that was provided to <code class="language-python">zip()</code>. Let's look at the following example of passing two lists:</p>
<pre><code class="language-python">numbers = [1, 2, 3]
words = ['one', 'two', 'three']
zip_iterator = zip(numbers, words)
print(list(zip_iterator))

# [(1, 'one'), (2, 'two'), (3, 'three')]</code></pre>
<p>Take a look at how <code class="language-python">zip()</code> takes the first element of <code class="language-python"><span style="color: #000000;">numbers</span></code><span style="color: #000000;">,</span> the first element of <code class="language-python">words</code> and zips them together into a tuple. It does the same thing for every other pair of elements. Remember, <code class="language-python">zip()</code> returns an iterator, so we need to convert it to a list first to print the whole output. </p>
<p>You can pass any iterable to <code class="language-python">zip()</code>. Mind the following snippet:</p>
<pre><code class="language-python">my_string = 'AFK'
my_tuple = ('Away', 'From', 'Keyboard')
zip_iterator = zip(my_string, my_tuple)  # Returns an iterator
print(list(zip_iterator))

# [('A', 'Away'), ('F', 'From'), ('K', 'Keyboard')]</code></pre>
<p> </p>
<p></p><div class="alert alert-warning">Using <code class="language-python">zip()</code> with unordered iterables like sets will return tuples that are paired up in random order.</div>
<p> </p>
<h5 id="iterables-with-different-lengths">Iterables with different lengths</h5>
<p>If you pass iterables of different lengths to <code class="language-python">zip()</code>, the number of the resulting tuples will always be equal to the <strong>shortest iterable</strong>. Any remaining data in the longer iterables will be discarded:</p>
<pre><code class="language-python">shortest = {'this', 'is', 'a', 'set'}
longest = [True, True, True, True, False, False]
zip_iterator = zip(shortest, longest)
print(list(zip_iterator))

# [('a', True), ('set', True), ('this', True), ('is', True)]</code></pre>
<p>In the above example, we have established a <code class="language-python">zip()</code> function with two data types: a set of four elements and a list of six. The first 4 <code class="language-python">True</code> values have been zipped together with the shorter set, but the <code class="language-python">False</code> values have been discarded, as they have no pair. Also, note the order â€” it is different!</p>
<p>You can pass only one iterable to <code class="language-python">zip()</code>. In this case, the resulting iterator will contain single element tuples:</p>
<pre><code class="language-python">solo_string = 'Han Solo'
zip_iterator = zip(solo_string)
print(list(zip_iterator))

# [('H',), ('a',), ('n',), (' ',), ('S',), ('o',), ('l',), ('o',)]
</code></pre>
<h5 id="zip-in-loops">Zip() in loops</h5>
<p>One of the most common uses of <code class="language-python">zip()</code> is to loop over multiple iterables simultaneously. It is called a parallel iteration. We can achieve this by using a <code class="language-python">for</code> loop over an iterator generated by <code class="language-python">zip()</code>:</p>
<pre><code class="language-python">planets = ['Earth', 'The Moon', 'Mars']
colors = ['blue', 'gray', 'red']
visited = [True, True, False]

for planet, color, visit in zip(planets, colors, visited):
    print(f'{planet} is {color}')
    print(f'Visited = {visit}')

# Earth is blue
# Visited = True
# The Moon is gray
# Visited = True
# Mars is red
# Visited = False</code></pre>
<p>In the example above, we feed <code class="language-python">zip()</code> three lists, and it returns an iterator of tuples. Each tuple has three elements, one from each list. In the <code class="language-python">for</code> loop header, we define a variable for each element in the generated tuple and then use them inside our print statements. The loop then goes over each tuple in the iterator one at a time and executes all the print statements. <a href="https://pythontutor.com/visualize.html#code=planets%20%3D%20%5B'Earth',%20'The%20Moon',%20'Mars'%5D%0Acolors%20%3D%20%5B'blue',%20'gray',%20'red'%5D%0Avisited%20%3D%20%5BTrue,%20True,%20False%5D%0A%0Afor%20planet,%20color,%20visit%20in%20zip%28planets,%20colors,%20visited%29%3A%0A%20%20%20%20print%28f'%7Bplanet%7D%20is%20%7Bcolor%7D'%29%0A%20%20%20%20print%28f'Visited%20%3D%20%7Bvisit%7D'%29&amp;cumulative=false&amp;curInstr=5&amp;heapPrimitives=nevernest&amp;mode=display&amp;origin=opt-frontend.js&amp;py=3&amp;rawInputLstJSON=%5B%5D&amp;textReferences=false" rel="noopener noreferrer nofollow" target="_blank">Here</a> you can find the code visualization that can help you to better understand how it works.</p>
<h5 id="parallel-iteration-with-dictionaries">Parallel iteration with dictionaries</h5>
<p>Parallel iteration is a little more tricky with dictionaries. By default,  <code class="language-python">zip()</code> will only generate tuples containing a dictionary's keys. To include both keys and values, you must use the <code class="language-python">.items()</code> method in the dictionary:</p>
<pre><code class="language-python">hero = {'name': 'Peter', 'age': 13}
villain = {'name': 'Hook', 'age': 41}
zipped = zip(hero.items(), villain.items())
print(list(zipped))

# [(('name', 'Peter'), ('name', 'Hook')), (('age', 13), ('age', 41))]

zipped = zip(hero.items(), villain.items())
for (hero_key, hero_value), (villain_key, villain_value) in zipped:
    print(f"The hero's {hero_key} is {hero_value}")
    print(f"The villain's {villain_key} is {villain_value}")

# The hero's name is Peter
# The villain's name is Hook
# The hero's age is 13
# The villain's age is 41
</code></pre>
<p>In the above example, we use <code class="language-python">.items()</code> to convert two dictionaries into item lists. Each list includes key-value tuple pairs. These lists are then zipped together to form an iterator where each generated tuple contains two nested tuples, one key-value pair from <code class="language-python">hero</code> and one from <code class="language-python">villain</code>. Then we assign our <code class="language-python">for</code> loop variables in the same nested pattern and loop through the iterator.</p>
<p> </p>
<p></p><div class="alert alert-warning">For clarity, we have printed our zip iterator as a list. However, this exhausts the iterator of all its tuples, so it needs to be defined again before being used in the <code class="language-python">for</code> loop.</div>
<p> </p>
<h5 id="unzipping">Unzipping</h5>
<p>Unzipping a sequence is as simple as adding an unpacking operator to an iterable provided to <code class="language-python">zip()</code>.</p>
<pre><code class="language-python">phrase = [('A', 'Away'), ('F', 'From'), ('K', 'Keyboard')]
unzipped = zip(*phrase)
print(list(unzipped))

# [('A', 'F', 'K'), ('Away', 'From', 'Keyboard')]</code></pre>
<p>It unpacks <code class="language-python">phrase</code> into three separate tuples, and after that, <code class="language-python">zip()</code> combines back together in parallel, just like any other group of iterables. </p>
<h5 id="conclusion">Conclusion</h5>
<p>Parallel iteration is very useful when you work with different data structures. We have learned how to use <code class="language-python">zip()</code> and combine iterables to iterate over them in parallel, as well as how to unzip these iterables further. Time to practice with a few examples!</p></body></html>
